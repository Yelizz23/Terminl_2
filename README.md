# Домашнее задание к занятию "3.2. Работа в терминале. Лекция 2"

#### 1. Какого типа команда cd? Попробуйте объяснить, почему она именно такого типа: опишите ход своих мыслей, если считаете, что она могла бы быть другого типа.
Команда cd - это встроенная в оболочку (внутренняя команда Linux). Для всех встроенных команд оболочки их выполнение выполняется быстро в том смысле, что оболочке не нужно искать их по заданному пути в переменной PATH, а также не нужно создавать процесс для ее выполнения.  
Напротив у внешних команд оболочка ищет свой путь, указанный в переменной PATH, а также должен быть создан новый процесс, и команда будет выполнена.
```
  vagrant@vagrant:~$  type cd
  cd is a shell builtin
```


#### 2. Какая альтернатива без pipe команде grep <some_string> <some_file> | wc -l?
Альтернатива команде grep <some_string> <some_file> | wc -l является команда
```
  vagrant@vagrant:~$  grep -c <some_string> <some_file>
```
Утилита grep решает множество задач, в основном она используется для поиска строк, соответствующих строке в тексте или содержимому файлов, oпция -c подсчитывает количество вхождений шаблона. Команда wc тоже подсчитывает количество строк или слов в тексте.


#### 3. Какой процесс с PID 1 является родителем для всех процессов в вашей виртуальной машине Ubuntu 20.04?
Для всех процессов в виртуальной машине родителем является systemd
```
  vagrant@vagrant:~$  pstree -a -p | head -n 1
```


#### 4. Как будет выглядеть команда, которая перенаправит вывод stderr ls на другую сессию терминала?
```
  vagrant@vagrant:~$  ls -l /tmp/hello 2 > /dev/pts/1
```


#### 5. Получится ли одновременно передать команде файл на stdin и вывести ее stdout в другой файл? Приведите работающий пример.
```
  vagrant@vagrant:~$  echo "Hello netology" | cat > file.txt
```


#### 6. Получится ли, находясь в графическом режиме, вывести данные из PTY в какой-либо из эмуляторов TTY? Сможете ли вы наблюдать выводимые данные?
 Что-бы вывести данные из PTY в какой-либо из эмуляторов TTY нужно переключится в TTY.
```
  vagrant@vagrant:~$  tty
  vagrant@vagrant:~$  echo "Hello netology" > /dev/tty1
```


#### 7. Выполните команду bash 5>&1. К чему она приведет? Что будет, если вы выполните echo netology > /proc/$$/fd/5? Почему так происходит?
Эта команда создаст новый дескриптор-5 и перенаправит его в стандартный дескриптор вывода (stdout).
Команда echo netology > /proc/$$/fd/5 выведет слово netology в окно консоли, выведет строку netology. Так происходит, потому что мы запросили вывод строки после создания дескриптора 5, если бы это сделали перед созданием, то была бы ошибка, так как дескриптор 5 не существует.


#### 8. Получится ли в качестве входного потока для pipe использовать только stderr команды, не потеряв при этом отображение stdout на pty? 
Да получится, если использовать тот же созданный дескриптор 5 и перенаправить его в д. 2 (stder), после д. 2 (stder) в д. 1 (stdout), и наконец д. 1 (stdout) в д. 5 (новый дескриптор). 
```
  vagrant@vagrant:~$  echo "Hello netology" 5>&2 2>&1 1>&5 | grep "Hello netology"
```


#### 9. Что выведет команда cat /proc/$$/environ? Как еще можно получить аналогичный по содержанию вывод? 
Команда cat /proc/$$/environ выведет список переменные окружения.
Аналогичный по содержанию вывод можно получить при помощи команды printenv или env


#### 10. Используя man, опишите что доступно по адресам /proc/<PID>/cmdline, /proc/<PID>/exe.
/proc/<PID>/cmdline: аргументы запускаемого процесса (Procedures to process command lines and options)
/proc/<PID>/exe: ссылка на путь к исполняемoму файлу


#### 11. Узнайте, какую наиболее старшую версию набора инструкций SSE поддерживает ваш процессор с помощью /proc/cpuinfo. 
```
  vagrant@vagrant:~$  grep sse /proc/cpuinfo
```
![snimok]( /Users/antonbannikov/desktop/snimok.png)

Наиболее старшей версией является 4.2.

#### 12. При открытии нового окна терминала и vagrant ssh создается новая сессия и выделяется pty. Это можно подтвердить командой tty, которая упоминалась в лекции 3.2. 
![snimok]( /Users/antonbannikov/desktop/snimok1.png)
 
По умолчанию псевдо-терминал не создается, это сделано для исправной работы скиптов. Принудительно это можно исправить следующим образом:
```
  vagrant@vagrant:~$  ssh localhost -t 'tty'
```


#### 13. Бывает, что есть необходимость переместить запущенный процесс из одной сессии в другую. Попробуйте сделать это, воспользовавшись reptyr. Например, так можно перенести в screen процесс, который вы запустили по ошибке в обычной SSH-сессии.
```
  vagrant@vagrant:~$  reptyr PID
```
3ахватит процесс с идентификатором PID и прикрепит его в другую сессию. 
После присоединения процесс будет принимать входные данные и записывать выходные данные в другую сессию. 
B файле /etc/sysctl.d/10-ptrace.conf изменим параметр kernel.yama.ptrace_scope на 0. 

Далее следуем инструкции [documentation](https://github.com/nelhage/reptyr#typical-usage-pattern):
```
  Start a long running process, e.g. top
  Background the process with CTRL-Z
  Resume the process in the background: bg
  Display your running background jobs with jobs -l, this should look like this:
  [1]+  4711 Stopped (signal)        top
  (The -l in jobs -l makes sure you'll get the PID)
  Disown the jobs from the current parent with disown top. After that, jobs will not show the job any more, but ps -a will.
  Start your terminal multiplexer of choice, e.g. tmux
  Reattach to the backgrounded process: reptyr 4711
  Detach your terminal multiplexer (e.g. CTRL-A D) and close ssh
  Reconnect ssh, attach to your multiplexer (e.g. tmux attach), rejoice!
```

#### 13. sudo echo string > /root/new_file не даст выполнить перенаправление под обычным пользователем, так как перенаправлением занимается процесс shell'а, который запущен без sudo под вашим пользователем. Для решения данной проблемы можно использовать конструкцию echo string | sudo tee /root/new_file. Узнайте? что делает команда tee и почему в отличие от sudo echo команда с sudo tee будет работать.
Команда tee в Linux нужна для записи вывода любой команды в один или несколько файлов (получит вывод от stdout через | в stdin), и может быть запущена от имени суперпользователя.
Команда принимает данные из одного источника и может сохранять их на выходе в нескольких местах.  
Kоманда echo string | sudo tee /root/new_file имеет повышенные права на запись, по этому будет работать.
